/**
 * Syntax Specification
 *
 * Contributors:
 *      Jeanderson Barros Candido - http://jeandersonbc.github.io
 *      Thiago Ferreira Patricio - http://github.com/tferreirap
 *      Patrik Pekarčík - https://github.com/ppatrik
 */
package net.acptools.suite.ide.lang.cpp.generated;

import java_cup.runtime.*;
import net.acptools.suite.ide.lang.cpp.util.*;
import net.acptools.suite.ide.lang.cpp.core.*;
import java.util.ArrayList;
import java.util.List;
import java.io.BufferedReader;
import java.io.FileReader;

import java_cup.runtime.Symbol;

init with {: SemanticAnalysis.parser = this;              :};

parser code {:

    public void report_error(String message, Object info) {
        StringBuffer m = new StringBuffer("Error");
        m.append(info);
        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
    }

    public Parser(Lexer lex, ComplexSymbolFactory sf) {
    	super(lex,sf);
    }

    public static void main(String[] args) {
        String filePath = args[0];
        try {
    	    System.out.println("Start compiling \"" + filePath + "\"...");
    	    ComplexSymbolFactory csf = new ComplexSymbolFactory();
    	    Lexer scanner = new Lexer(new BufferedReader(new FileReader(filePath)), csf);
    	    Parser parser = new Parser(scanner, csf);
    		ComplexSymbolFactory.ComplexSymbol s = (ComplexSymbolFactory.ComplexSymbol)parser.parse();

    		if ("$START".equals(s.getName()))
    			System.out.println("> SUCCESSFULL COMPILATION: " + filePath);
    		else
    			System.out.println(s);

    	} catch (Exception e) {
    		System.err.println("Failed to compile \"" + filePath + "\":");
    		System.err.println(e.getMessage());
    		e.printStackTrace();
    	}
    }
:};


/**
 * Terminals without associated type
 */
terminal SEMICOLON, LBRK, RBRK, USING, ASSIGNMENT, LSQRBRK, RSQRBRK, ORASSIGN, GTE, EXTERN, ARROW, CONST, VOLATILE;
terminal SINGLEAND, DOUBLEAND, NOEXCEPT, QUESTION, ANDASSIGN, LT, GT, STATIC_ASSERT, MULTASSIGN, DIVASSIGN, MODASSIGN;
terminal PLUSASSIGN, MINUSASSIGN, RSHIFTASSIGN, LSHIFTASSIGN, LTE, DOT, TYPENAME, LPAR, RPAR, ALIGNAS, DOTS, CLASS, STRUCT;
terminal UNION, FINAL, EXPLICIT, COMMA, COLON, NEQOP, LSHIFT, CONSTEXPR, XORASSIGN, STAR, SEPPTR, OROP, SOROP, XOROP, EQOP;
terminal RSHIFT, DIVOP, MODOP, DOTSTAR, ARROWSTAR, FRIEND, MINUSOP, PLUSOP, ALIGNOF, AUTOINCRM, AUTODECRM, SIZEOF, LOGNEGATION;
terminal BINNEG, TYPEID, TYPEDEF, THIS, NULLPTR, PRIVATE, PUBLIC;
terminal PROTECTED, DECLTYPE, DEFAULT, INTEGER, STRING_LITERAL, STRING;

terminal AUTO, BREAK, CASE, CHAR, CONTINUE, DO, DOUBLE, ELSE, FLOAT, FOR, GOTO, IF, INT, BOOL, BYTE, WORD, FLOATING,
LONG, REGISTER, RETURN, SHORT, SIGNED, STATIC, SWITCH, UNSIGNED, VOID, WHILE, OPERATOR, NEW ;

terminal INCLUDE, INCLUDE_LITERAL, DEFINE;

/**
 * Terminals with types associated  terminal java.lang.String IDENTIFIER;
 */

terminal IDENTIFIER;
terminal TRUE, FALSE;

/**
 * Non terminal symbols
 */
non terminal typeIdListOpt, typeIdList, conditionalExpr, primaryExpr, attributeOpt;
non terminal initDeclaratorListOpt, balancedToken, assignmentOperator, functionDef, functionBody, declSpecSeqOpt, declarator;
non terminal inclusiveOrExpr, exclusiveOrExpr, andExpr, equalityExpr, relationalExpr, shiftExpr, enumList;
non terminal classVirtSpecSeqOpt, classVirtSpecSeq, refQualifierOpt, deleteExpr, ptrDeclarator;
non terminal userDefinedLiteral, floatingLiteral, lambdaIntroducer, lambdaDeclaratorOpt, compoundStatement, declSpec;
non terminal trailingReturnType, trailingTypeSpecSeq, cvQualifierSeqOpt, cvQualifier, nestedNameSpec, pointerLiteral;
non terminal additiveExpr, unqualifiedId, typeSpecSeq, abstractDeclaratorOpt, abstractDeclarator, typeSpec, constExpr, unaryExpr, booleanLiteral;
non terminal simpleTypeSpec, elaboratedTypeSpec, typenameSpec, ptrAbstractDeclaratorOpt, castExpr, characterLiteral;
non terminal attributeToken, attributeArgClsOpt, attributeArgCls, attributeScopedToken, balancedTokenSeq, attribute;
non terminal memberSpecification, classKey, classHead2, classHeadName, enumHead, literal, usingDecl;
non terminal bracedInitList, commaOpt, initializeList, assignmentExprOpt, postfixExpr, unaryOp, idExpr;
non terminal typeSpecSeq2, attributeSpecSeqOpt, attributeSpecSeq, paramDeclarationCls, enumListOpt, stringLiteral;
non terminal translationUnit, blockDeclaration, aliasDeclaration, multExpr, integerLiteral;
non terminal logicalOrExpr, expr, assignmentExpr, initializeCls, throwExpr, logicalAndExpr, newExpr, qualifiedId;
non terminal classOrDeclType, className, declTypeSpec, accessSpec, accessSpecOpt;
non terminal attributeSpec, attributeList, alignmentSpec, dotsOpt, classHead, cvQualifierSeq, exprListOpt, token;
non terminal trailingTypeSpec, classSpec, enumSpec, memberSpecificationOpt, bracedInitListOpt;
non terminal noPtrDeclarator, linkageSpec, memInitializerId, noPtrAbstractDeclarator, ptrOperator, parametersAndQualifiers;
non terminal attributeDecl, simpleDecl, classVirtSpec, ptrAbstractDeclarator, refQualifier, pmExpr, lambdaExpr;

non terminal declarationSeqOpt, declarationSeq, declaration, emptyDeclaration, typeId, pseudoDestructorName;
non terminal identifierOpt, declSpecSeq, memInitializerList, memInitializer, declaratorId, storageClassSpec;
non terminal functionSpec, sepptrOpt, typeName, nestedNameSpecOpt, enumName;
non terminal typedefName, ctorInitializerOpt, paramDeclarationListOpt, paramDeclarationList, paramDeclaration;
non terminal statementSeqOpt, statementSeq, statement, exprStatement, selectionStatement, iterationStatement;
non terminal jumpStatement, tryBlock, labeledStatement, declStatement, exprOpt, overloadableOperator, operatorFunctionId;
non terminal conversionFunctionId, conversionTypeId, conversionDeclaratorOpt, conversionDeclarator, condition, conditionOpt;
non terminal initDeclaratorList, initDeclarator, initializerOpt, initializer, braceOrEqualInitializer, forInitStatement;
non terminal forStatement, forRangeInitializer, forRangeDeclaration, ruleAux;

non terminal decimal_Literal, integerSuffix;

non terminal includeDef, includeFileLit, defineDef;


/**
 * Precedences
 */
precedence nonassoc DOTS, LPAR, LSQRBRK;

precedence left PLUSOP, MINUSOP;
precedence left DIVOP;

/**
 * The Grammar Specification
 *
 * See "README.md" on "http://github.com/jeandersonbc/compilers.cpp"
 * for further information.
 */
start with translationUnit;

translationUnit
    ::= declarationSeqOpt               {: Logger.print("120 translationUnit (declarationSeqOpt)"); :}
    ;

declarationSeqOpt
    ::= declarationSeq                  {: Logger.print("121 declarationSeqOpt (declarationSeq)"); :}
    |                                   {: Logger.print("121 declarationSeqOpt (empty)"); :}
    ;

declarationSeq
    ::= declaration                     {: Logger.print("122 declarationSeq (declaration)"); :}
    |  declarationSeq declaration       {: Logger.print("122 declarationSeq (declarationSeq declaration)"); :}
    ;

/**
 * Declaration Types
 */

declaration
    ::= blockDeclaration:b              {: Logger.print("130 declaration (blockDeclaration:b) "  + b); :}
    |   functionDef:f                   {: Logger.print("130 declaration (functionDef:f) "  + f); :}
    |   linkageSpec                     {: Logger.print("130 declaration (linkageSpec)"); :}
    |   emptyDeclaration                {: Logger.print("130 declaration (emptyDeclaration)"); :}
    |   attributeDecl                   {: Logger.print("130 declaration (attributeDecl)" ); :}
    |   includeDef:i                    {: Logger.print("130 declaration (includeDef) " + i); :}
    |   defineDef:i                     {: Logger.print("130 declaration (defineDef) " + i); :}
    ;


/**
 * Include declaration
 */

includeDef
    ::= INCLUDE includeFileLit:il       {: Logger.print("131 includeDef(INCLUDE includeFileLit:il) " + il); SemanticAnalysis.getInstance().addInclude(il.toString()); RESULT = il; :}
    ;

includeFileLit
    ::= INCLUDE_LITERAL:il              {: Logger.print("132 includeFileLit(INCLUDE_LITERAL:il) " + il); RESULT = il; :}
    |   STRING_LITERAL:sl               {: Logger.print("132 includeFileLit(STRING_LITERAL:sl) " + sl); RESULT = sl; :}
    ;

/**
 * Define declaration
 */

defineDef
    ::= DEFINE declaratorId:de initializeCls:i     {: Logger.print("187 defineDef " + de + " " + i); :}
    ;

/**
 * Attribute Declaration
 */
attributeDecl
    ::= attributeSpecSeq SEMICOLON
    ;

/**
 * Linkage Specification
 */
linkageSpec ::= EXTERN stringLiteral LBRK declSpecSeqOpt RBRK
    |   EXTERN stringLiteral declaration
    ;


identifierOpt ::= IDENTIFIER | ;

/**
 * Function Definition
 */

 functionDef
    ::= declSpec:d declarator:de       {: Logger.print("pre-159 declSpec: " + d + " declarator: " + de); ((Function) de).setReturnType((Type) d); SemanticAnalysis.getInstance().addFunctionAndNewScope((Function) de); :}  functionBody:fb {: Logger.print("159 " + d + " " + fb);  SemanticAnalysis.getInstance().exitCurrentScope(); :}
    ;





declSpecSeqOpt
    ::= declSpecSeq
    |
    ;

declSpecSeq
    ::= declSpec
    |   declSpec declSpecSeq
    ;


declSpec
    ::= storageClassSpec:s          {: Logger.print("168 storageClassSpec" + s); RESULT = s; :}
    |   typeSpec:t                  {: Logger.print("169 typeSpec " + t); RESULT = t; :}
    |   functionSpec:f              {: Logger.print("170 functionSpec" + f); RESULT = f; :}
    |   FRIEND                      {: RESULT = new Node("friend", "primario");  Logger.print("friend"); :}
    |   TYPEDEF                     {: RESULT = new Node("typedef", "primario");  Logger.print("typedef"); :}
    |   CONSTEXPR                   {: RESULT = new Node("constexpr", "primario");  Logger.print("constexpr"); :}
    ;

storageClassSpec ::= AUTO           {: RESULT = new Node("auto", "primario");  Logger.print("auto");:}
    | REGISTER                      {: RESULT = new Node("register", "primario");  Logger.print("register");:}
    | STATIC                        {: RESULT = new Node("static", "primario");  Logger.print("static");:}
    | EXTERN                        {: RESULT = new Node("extern", "primario");  Logger.print("extern");:}
    ;

functionSpec ::= EXPLICIT;

typeSpec ::= trailingTypeSpec:t     {: Logger.print("184 trailingTypeSpec " + t); RESULT = t; :}
    |   classSpec:c                 {: Logger.print("185 classSpec " + c); RESULT = c; :}
    |   enumSpec
    ;

typeName ::= className
    |   enumName
    |   typedefName
    ;

enumName ::= IDENTIFIER;

typedefName ::= IDENTIFIER;

trailingTypeSpec
    ::= simpleTypeSpec:s {: Logger.print("198 trailingTypeSpec (simpleTypeSpec:s) " + s); RESULT = s; :}
    |   elaboratedTypeSpec
    |   typenameSpec
    |   cvQualifier:c trailingTypeSpec:s {: Logger.print("198 trailingTypeSpec (cvQualifier:c trailingTypeSpec:s) " + c + " " + s); RESULT = new Type(((Type)c).getName() + " " + ((Type)s).getName()); :}
    |   cvQualifier:c trailingTypeSpec:s STAR {: Logger.print("198 trailingTypeSpec (cvQualifier:c trailingTypeSpec:s STAR) " + c + " " + s); RESULT = new Type(((Type)c).getName() + " " + ((Type)s).getName() + "*"); :}
    ;

sepptrOpt ::= SEPPTR | ;

nestedNameSpecOpt ::= nestedNameSpec | ;

nestedNameSpec ::= typeName COLON COLON
    | declTypeSpec COLON COLON
    | nestedNameSpec IDENTIFIER COLON COLON
    ;

simpleTypeSpec
    ::= sepptrOpt nestedNameSpecOpt typeName
    |   UNSIGNED CHAR       {: RESULT = new Type("unsigned char"); :}
    |   UNSIGNED INT        {: RESULT = new Type("unsigned int"); :}
    |   UNSIGNED LONG       {: RESULT = new Type("unsigned long"); :}
    |   STRING              {: RESULT = new Type("string"); :}
    |   BOOL                {: RESULT = new Type("bool"); :}
    |   BYTE                {: RESULT = new Type("byte"); :}
    |   SHORT               {: RESULT = new Type("short"); :}
    |   SIGNED              {: RESULT = new Type("signed"); :}
    |   FLOAT               {: RESULT = new Type("float"); :}
    |   DOUBLE              {: RESULT = new Type("double"); :}
    |   CHAR                {: RESULT = new Type("char"); :}
    |   INT                 {: RESULT = new Type("int"); :}
    |   LONG                {: RESULT = new Type("long"); :}
    |   VOID                {: RESULT = new Type("void"); :}
    |   WORD                {: RESULT = new Type("word"); :}
    |   AUTO                {: RESULT = new Type("auto"); :}
    |   declTypeSpec
    ;

functionBody ::= COLON memInitializerList compoundStatement
    |   compoundStatement:c          {: Logger.print("229 funcBody -> compoundStatement " + c ); RESULT = c; :}
    ;

memInitializerList ::= memInitializer dotsOpt
    |   memInitializer COMMA memInitializerList dotsOpt
    ;

memInitializer ::= memInitializerId LPAR exprListOpt RPAR
    |   memInitializerId bracedInitList
    ;

memInitializerId ::= classOrDeclType
    | IDENTIFIER
    ;

declarator
    ::= ptrDeclarator:p                                                    {: Logger.print("244 declarator (ptrDeclarator:p) " + p ); RESULT = p; :}
    |   noPtrDeclarator:p parametersAndQualifiers trailingReturnType       {: Logger.print("244 declarator (noPtrDeclarator:p parametersAndQualifiers trailingReturnType) " + p ); RESULT = p; :}
    ;

ptrDeclarator
    ::= noPtrDeclarator:n                       {: Logger.print("248 noPtrDeclarator " + n);  RESULT = n; :}
    |   ptrOperator:o ptrDeclarator:p           {: Logger.print("249 ptrDeclarator " + p + " " + o); RESULT = p; :}
    ;

noPtrDeclarator
    ::= declaratorId:d                                                      {: Logger.print("252 declaratorId " + d ); RESULT = d; :}
    |   noPtrDeclarator:n parametersAndQualifiers:p                         {: Logger.print("252 noptrDeclarator " + n + " paramsQualifiers " + p ); RESULT = new Function(n.toString(), (ArrayList<Parameter>) p); :}
    |   noPtrDeclarator:n LSQRBRK constExpr:c RSQRBRK attributeSpecSeqOpt   {: Logger.print("252 noPtrDeclarator (noPtrDeclarator LSQRBRK constExpr RSQRBRK attributeSpecSeqOpt) " + n + " " + c); RESULT = n; :}
    |   noPtrDeclarator:n LSQRBRK RSQRBRK attributeSpecSeqOpt               {: Logger.print("252 noPtrDeclarator (noPtrDeclarator LSQRBRK RSQRBRK attributeSpecSeqOpt) "); RESULT = n; :}
    |   LPAR ptrDeclarator:pd RPAR                                          {: Logger.print("252 noPtrDeclarator (LPAR ptrDeclarator RPAR) " + pd); :}
    ;

declaratorId ::= idExpr:idE                     {: Logger.print("259 idExpr " + idE ); RESULT = idE; :}
    |   DOTS idExpr
    |   COLON COLON nestedNameSpecOpt className
    |   COLON COLON className
    |   nestedNameSpec className
    |   className
    ;

/**
 * Block Declaration
 */
// PAROU AQUI
blockDeclaration ::= simpleDecl:s               {: Logger.print("276 simpleDecl " + s ); RESULT = s; :}
    |   aliasDeclaration
    ;

/** TO DELETE
* simpleDecl ::= declSpecSeqOpt initDeclaratorListOpt SEMICOLON;
*/

simpleDecl
    ::= declSpec:d SEMICOLON                         {: Logger.print("284 simpleDecl (declSpec:d SEMICOLON) " + d); :}
    |   declSpec:d initDeclaratorList:i SEMICOLON    {: Logger.print("285 simpleDecl (declSpec:d initDeclaratorList:i SEMICOLON) " + d + " " + i); ((Variable) i).setType((Type) d); SemanticAnalysis.getInstance().addVariable((Variable) i); RESULT = i; :}
    ;


initDeclaratorListOpt ::= initDeclaratorList | ;

initDeclaratorList ::= initDeclarator:i                 {: Logger.print("291 " + i); RESULT = i; :}
    |   initDeclaratorList:il COMMA initDeclarator:id   {: Logger.print("292 " + il + " " + id); RESULT = il; :}
    ;

initDeclarator ::= declarator:d     {: Logger.print("295 " + d); RESULT = new Variable(d.toString(), new Type("UNKNOWN")); :}
    | declarator:d ASSIGNMENT initializeCls:i {: Variable v = new Variable(d.toString(), new Type("UNKNOWN")); v.setValue(i); RESULT = v; :}
    ;

initializerOpt ::= initializer | ;

initializer ::= braceOrEqualInitializer
    |   LPAR exprListOpt RPAR
    ;

braceOrEqualInitializer ::= ASSIGNMENT initializeCls
    |   bracedInitList
    ;

aliasDeclaration ::= USING IDENTIFIER ASSIGNMENT typeId SEMICOLON;

typeId ::= typeSpecSeq abstractDeclaratorOpt;

abstractDeclaratorOpt ::= abstractDeclarator | ;

abstractDeclarator ::= ptrAbstractDeclarator
    |   noPtrAbstractDeclarator parametersAndQualifiers trailingReturnType
    |   parametersAndQualifiers trailingReturnType
    |   DOTS
    ;

/** parametersAndQualifiers ::= LPAR paramDeclarationCls:p RPAR  {: Logger.print("307 paramsQualifiers " + p ); RESULT = (ArrayList<Parameter>) p; :} ; */

parametersAndQualifiers ::= LPAR RPAR  {: Logger.print("309 paramsQualifiers ()" );      RESULT = new ArrayList<Parameter>(); :}
    | LPAR paramDeclarationCls:pList RPAR  {: Logger.print("310 paramsQualifiers (plist)");  RESULT = pList; :}
    ;

paramDeclarationCls ::= paramDeclarationList:p      {: RESULT = p;  Logger.print("313 parameterDeclaration " + p); :}
    | paramDeclarationList COMMA DOTS
    ;

paramDeclarationListOpt ::= paramDeclarationList | ;

paramDeclarationList ::= paramDeclaration:pd        {:  RESULT = Util.newList( (Parameter) pd );  Logger.print("319 parameter_declaration " + pd);:}
    | paramDeclarationList:plist COMMA paramDeclaration:p {: Logger.print("320 " + plist + ": " + p); ((ArrayList<Parameter>) plist).add((Parameter)p); RESULT = plist;:}
    ;

paramDeclaration ::= declSpec:d declarator:de  {: Logger.print("323 " + d + " " + de); Variable v = new Variable(de.toString(), (Type) d); RESULT = v; :}
    |   declSpecSeq declarator ASSIGNMENT initializeCls
    |   declSpecSeq abstractDeclaratorOpt
    |   declSpecSeq abstractDeclaratorOpt ASSIGNMENT initializeCls
    ;

cvQualifierSeqOpt
    ::= cvQualifierSeq
    |
    ;

/**
 * Expressions
 */
expr
    ::= assignmentExpr:a               {: Logger.print("338 assignmentExpr " + a); RESULT = a; :}
    |   expr:e COMMA assignmentExpr:a   {: Logger.print("339 expr: " + e + " assignExpr: " + a); :}
    ;

constExpr
    ::= conditionalExpr:e                  {: Logger.print("412 constExpr (conditionalExpr) " + e); RESULT = e; :}
    ;

conditionalExpr
    ::= logicalOrExpr:l                                                  {: Logger.print("344 logicalOrExpr " + l); RESULT = l; :}
    |   logicalOrExpr QUESTION assignmentExpr:e1 COLON assignmentExpr:e2 {: Logger.print("344 logicalOrExpr2 " + e1); RESULT = e1; :}
    ;

assignmentExprOpt
    ::= assignmentExpr
    |
    ;

assignmentExpr
    ::= conditionalExpr:e                            {: Logger.print("351 conditionExpr " + e); RESULT = e; :}
    |   logicalOrExpr:u assignmentOperator:o initializeCls:e    {: Logger.print("352 logicalOrExpr: " + u + " assignOp: " + o + " initializeCls" + e); RESULT = e; :}
    ;


assignmentOperator
    ::= ASSIGNMENT   {: RESULT = new Node("=", "primario");  Logger.print("=");:}
    |   MULTASSIGN                  {: RESULT = new Node("*=", "primario"); Logger.print("*=");:}
    |   DIVASSIGN                   {: RESULT = new Node("/=", "primario"); Logger.print("/=");:}
    |   MODASSIGN                   {: RESULT = new Node("%=", "primario"); Logger.print("%=");:}
    |   PLUSASSIGN                  {: RESULT = new Node("+=", "primario"); Logger.print("+=");:}
    |   MINUSASSIGN                 {: RESULT = new Node("-=", "primario"); Logger.print("-=");:}
    |   RSHIFTASSIGN                {: RESULT = new Node(">>=","primario"); Logger.print(">>=");:}
    |   LSHIFTASSIGN                {: RESULT = new Node("<<=","primario"); Logger.print("<<=");:}
    |   ANDASSIGN                   {: RESULT = new Node("&=", "primario"); Logger.print("&=");:}
    |   XORASSIGN                   {: RESULT = new Node("^=", "primario"); Logger.print("^=");:}
    |   ORASSIGN                    {: RESULT = new Node("|=", "primario"); Logger.print("|=");:}
    ;


initializeCls
    ::= assignmentExpr:ae       {: Logger.print("370 initializeCls (assignmentExpr:ae) " + ae); RESULT = ae; :}
    |   bracedInitList:bl       {: Logger.print("370 initializeCls (bracedInitList:bl) "); RESULT = bl; :}
    ;

bracedInitList
    ::= LBRK initializeList:il commaOpt RBRK     {: Logger.print("453 bracedInitList (LBRK initializeList:il commaOpt RBRK) " + il); RESULT = il; :}
    |   LBRK RBRK                                {: Logger.print("453 bracedInitList (LBRK RBRK) "); RESULT = Util.newList(); :}
    ;

initializeList
    ::= initializeCls:i                             {: Logger.print("458 initializeList (initializeCls:i) " + i); RESULT = Util.newList(Util.asExpression(i)); :}
    | initializeList:iList COMMA initializeCls:i    {: ((ArrayList<Expression>) iList).add((Expression)i); RESULT = iList; :}
    ;

commaOpt ::= COMMA | ;

logicalOrExpr ::= logicalAndExpr:l              {: Logger.print("383 " + l); RESULT = l; :}
    |   logicalOrExpr:l OROP logicalAndExpr:e   {: Logger.print("384 " + l + " " + e); RESULT = SemanticAnalysis.getInstance().getExpressionForOperation(Operation.OR_OP, l, e); :}
    ;

logicalAndExpr ::= inclusiveOrExpr:e                  {: Logger.print("387 " + e); RESULT = e; :}
    |   logicalAndExpr:l DOUBLEAND inclusiveOrExpr:i  {: Logger.print("388 " + l + " " + i); RESULT = SemanticAnalysis.getInstance().getExpressionForOperation(Operation.AND_OP, l, i); :}
    ;

inclusiveOrExpr ::= exclusiveOrExpr:e               {: Logger.print("391 " + e); RESULT = e; :}
    |   inclusiveOrExpr:i SOROP exclusiveOrExpr:e   {: Logger.print("392 " + i + " " + e); :}
    ;

exclusiveOrExpr ::= andExpr:a               {: Logger.print("395 " + a); RESULT = a; :}
    | exclusiveOrExpr:e XOROP andExpr:a     {: Logger.print("396 " + e + " " + a); :}
    ;

andExpr ::= equalityExpr:e                  {: Logger.print("399 " + e); RESULT = e; :}
    | andExpr:a SINGLEAND equalityExpr:e    {: Logger.print("400 " + a + " " + e); :}
    ;

equalityExpr ::= relationalExpr:r               {: Logger.print("403 " + r); RESULT = r; :}
    |   equalityExpr:e EQOP relationalExpr:r    {: Logger.print("404 " + e + " operator " + r); RESULT = SemanticAnalysis.getInstance().getExpressionForOperation(Operation.EQ_OP, e, r); :}
    |   equalityExpr:e NEQOP relationalExpr:r   {: Logger.print("405 " + e + " operator " + r); RESULT = SemanticAnalysis.getInstance().getExpressionForOperation(Operation.NE_OP, e, r); :}
    ;

relationalExpr ::= shiftExpr:s              {: Logger.print("408 " + s); RESULT = s; :}
    |   relationalExpr:r LT shiftExpr:s     {: Logger.print("409 " + r + " " + s); RESULT = SemanticAnalysis.getInstance().getExpressionForOperation(Operation.LESS_THAN, r, s); :}
    |   relationalExpr:r GT shiftExpr:s     {: Logger.print("410 " + r + " " + s); RESULT = SemanticAnalysis.getInstance().getExpressionForOperation(Operation.MORE_THAN, r, s); :}
    |   relationalExpr:r LTE shiftExpr:s    {: Logger.print("411 " + r + " " + s); RESULT = SemanticAnalysis.getInstance().getExpressionForOperation(Operation.LE_OP, r, s); :}
    |   relationalExpr:r GTE shiftExpr:s    {: Logger.print("412 " + r + " " + s); RESULT = SemanticAnalysis.getInstance().getExpressionForOperation(Operation.GE_OP, r, s); :}
    ;

shiftExpr ::= additiveExpr:a                {: Logger.print("415 " + a); RESULT = a; :}
    |   shiftExpr:s LSHIFT additiveExpr:a   {: Logger.print("416 " + s + " " + a); :}
    |   shiftExpr:s RSHIFT additiveExpr:a   {: Logger.print("417 " + s + " " + a); :}
    ;

additiveExpr ::= multExpr:m                 {: Logger.print("420 " + m); RESULT = m; :}
    |   additiveExpr:a PLUSOP multExpr:m    {: Logger.print("421 " + a + " " + m); RESULT = SemanticAnalysis.getInstance().getExpressionForOperation(Operation.PLUS, a, m); :}
    |   additiveExpr:a MINUSOP multExpr:m   {: Logger.print("422 " + a + " " + m); RESULT = SemanticAnalysis.getInstance().getExpressionForOperation(Operation.MINUS, a, m); :}
    ;

multExpr ::= castExpr:p                   {: Logger.print("426 " + p); RESULT = p; :}
    |   multExpr:m STAR castExpr:c        {: Logger.print("427 " + m + " " + c); RESULT = SemanticAnalysis.getInstance().getExpressionForOperation(Operation.MULT, m, c); :}
    |   multExpr:m DIVOP castExpr:c       {: Logger.print("428 " + m + " " + c); RESULT = SemanticAnalysis.getInstance().getExpressionForOperation(Operation.DIV, m, c); :}
    |   multExpr:m MODOP castExpr:c       {: Logger.print("429 " + m + " " + c); RESULT = SemanticAnalysis.getInstance().getExpressionForOperation(Operation.PERC, (Expression) m, (Expression) c); :}
    ;

pmExpr ::= castExpr
    |   pmExpr DOTSTAR castExpr
    |   pmExpr ARROWSTAR castExpr
    ;

castExpr ::= unaryExpr:u                {: Logger.print("437 " + u); RESULT = u; :}
    |   LPAR typeId:t RPAR castExpr:c   {: Logger.print("438 " + t + " " + c); :}
    ;

unaryExpr ::= postfixExpr:p                     {: Logger.print("441 " + p); RESULT = p; :}
    |   AUTOINCRM castExpr:c                    {: Logger.print("442 " + c); RESULT = c; :}
    |   AUTODECRM castExpr:c                    {: Logger.print("443 " + c); RESULT = c; :}
    |   unaryOp:u castExpr:c                    {: Logger.print("444 " + u + " " + c); RESULT = c; :}
    |   SIZEOF unaryExpr:u                      {: Logger.print("445 " + u); RESULT = u; :}
    |   SIZEOF LPAR typeId:t RPAR               {: Logger.print("97 " + t); RESULT = t; :}
    |   SIZEOF DOTS LPAR IDENTIFIER RPAR
    |   ALIGNOF LPAR typeId RPAR
    |   newExpr
    |   deleteExpr
    ;

unaryOp ::= STAR        {: RESULT = new Node("*", "primario"); Logger.print("*");:}
    |   SINGLEAND       {: RESULT = new Node("&", "primario"); Logger.print("&"); :}
    |   PLUSOP          {: RESULT = new Node("+", "primario"); Logger.print("+");:}
    |   MINUSOP         {: RESULT = new Node("-", "primario"); Logger.print("-");:}
    |   LOGNEGATION     {: RESULT = new Node("!", "primario"); Logger.print("!");:}
    |   BINNEG          {: RESULT = new Node("~", "primario"); Logger.print("~");:}
    ;

postfixExpr ::= primaryExpr:p                              {: Logger.print("461 " + p); RESULT = p; :}
    |   postfixExpr:p LSQRBRK expr:e RSQRBRK               {: Logger.print("462 " + e); RESULT = p; :}
    |   postfixExpr:p LSQRBRK bracedInitListOpt RSQRBRK    {: Logger.print("463 " + p); RESULT = p; :}
    |   postfixExpr:p LPAR RPAR                            {: Logger.print("464 " + p); ComplexSymbolFactory.ComplexSymbol ps = (ComplexSymbolFactory.ComplexSymbol) CUP$Parser$stack.elementAt(CUP$Parser$top); if(SemanticAnalysis.getInstance().isFunction(p, ps) && SemanticAnalysis.getInstance().checkFunctionCallException(((Function) p).getName(), ps)) { RESULT = new Expression(((Function)p).getReturnType()); } :}
    |   postfixExpr:p LPAR initializeList:i RPAR           {: Logger.print("465 " + p + " " + i); ComplexSymbolFactory.ComplexSymbol ps = (ComplexSymbolFactory.ComplexSymbol) CUP$Parser$stack.elementAt(CUP$Parser$top); Type[] types = Util.convertToTypeArray((ArrayList<Expression>) i); if(SemanticAnalysis.getInstance().isFunction(p, types, ps) && SemanticAnalysis.getInstance().checkFunctionCallException(((Function) p).getName(), types, ps)) { RESULT = new Expression(((Function)p).getReturnType()); } :}
    |   simpleTypeSpec:st LPAR exprListOpt RPAR            {: Logger.print("466 " + st); Function e = new Function(((Type)st).getName()); e.setReturnType((Type)st); RESULT = e; :}
    |   typenameSpec LPAR exprListOpt RPAR                 {: Logger.print("467 "); :}
    |   simpleTypeSpec bracedInitList                      {: Logger.print("468 "); :}
    |   typenameSpec bracedInitList                        {: Logger.print("469 "); :}
    |   postfixExpr:p DOT idExpr:e                         {: Logger.print("646p1 " + p); RESULT = SemanticAnalysis.getInstance().createMethodFunction((Expression)p, (String)e); :}
    |   postfixExpr:p ARROW idExpr:e                       {: Logger.print("646p1 " + p); RESULT = SemanticAnalysis.getInstance().createMethodFunction((Expression)p, (String)e); :}
    |   postfixExpr:p DOT pseudoDestructorName             {: Logger.print("470 " + p); RESULT = p; :}
    |   postfixExpr:p AUTOINCRM                            {: Logger.print("471 " + p); RESULT = p; :}
    |   postfixExpr:p AUTODECRM                            {: Logger.print("472 " + p); RESULT = p; :}
    ;

idExpr ::= unqualifiedId:u       {: Logger.print("471 unqualifiedID " + u ); RESULT = u; :}
    |   qualifiedId
    ;

unqualifiedId ::= IDENTIFIER:i    {: Logger.print("475 identifier " + i ); RESULT = i; :}
    |   operatorFunctionId
    |   conversionFunctionId
    |   BINNEG className
    ;

operatorFunctionId ::= OPERATOR overloadableOperator;

conversionFunctionId ::= OPERATOR conversionTypeId;

conversionTypeId ::= typeSpecSeq conversionDeclaratorOpt;

/* COMMENT FOR NOW */
/*
 * conversionDeclarator ::= ptrOperator conversionDeclaratorOpt;
 * conversionDeclaratorOpt ::= conversionDeclarator | ;
*/


primaryExpr ::= literal:l           {: RESULT = l;  Logger.print("499 literal " + l); :}
    |   THIS
    |   LPAR expr:e RPAR            {: RESULT = e;  Logger.print("501 expression " + e); :}
    |   idExpr:i                   {: Logger.print("502 " + i); RESULT = SemanticAnalysis.getInstance().getIdentifier((String) i); :}
    ;

lambdaExpr ::= lambdaIntroducer lambdaDeclaratorOpt compoundStatement;

compoundStatement ::= LBRK RBRK
    | LBRK statementSeq:s RBRK {: RESULT = s;  Logger.print("514 statementSeq" + s); :}
    ;

statementSeqOpt ::= statementSeq | ;

statementSeq ::= statement:s {: RESULT = s;  Logger.print("519 statement " + s);:}
    | statementSeq statement
    ;

statement ::= labeledStatement:s    {: Logger.print("ANTES 529 labeled"); RESULT = s;  Logger.print("523 labeled_statement: " + s);:}
    |   exprOpt:s                   {: Logger.print("ANTES 529 expression"); RESULT = s;  Logger.print("524 exprOpt_statement: " + s);:}
    |   compoundStatement:s         {: Logger.print("ANTES 529 compound"); RESULT = s;  Logger.print("525 compound_statement: " + s);:}
    |   selectionStatement:s        {: Logger.print("ANTES 529 selection"); RESULT = s;  Logger.print("526 selection_statement: " + s);:}
    |   iterationStatement:s        {: RESULT = s;  Logger.print("527 iteration_statement: " + s);:}
    |   jumpStatement:s             {: RESULT = s;  Logger.print("528 jump_statement: " + s);:}
    |   blockDeclaration:s          {: Logger.print("ANTES 529 blockDeclaration_statement");  RESULT = s;  Logger.print("529 blockDeclaration_statement: " + s);:}
    |   tryBlock:s                  {: RESULT = s;  Logger.print("530 tryBlock_statement: " + s);:}
    ;


labeledStatement ::= IDENTIFIER COLON statement
    |   CASE constExpr COLON statement
    |   DEFAULT COLON statement
    ;

/*
*exprOpt ::= expr | ;
*/

exprOpt ::= SEMICOLON
    | expr SEMICOLON
    ;

/*
selectionStatement ::= IF LPAR condition:c RPAR {: Logger.print("551 if condition "); SemanticAnalysis.getInstance().createIf(c); :}  statement:s {: SemanticAnalysis.getInstance().exitCurrentScope(); :}
    |   IF LPAR condition:c RPAR statement:s ELSE statement
    |   SWITCH LPAR condition RPAR statement
    ;
*/

/*
selectionStatement ::= IF LPAR condition:c RPAR {: Logger.print("551 if condition "); SemanticAnalysis.getInstance().createIf(c); :}  statement:s {: SemanticAnalysis.getInstance().exitCurrentScope(); :}
    ;
*/

selectionStatement ::= IF LPAR condition:c RPAR {: Logger.print("551 if condition "); SemanticAnalysis.getInstance().createIf(c); :}  statement:s {: SemanticAnalysis.getInstance().exitCurrentScope(); :}  ruleAux;

ruleAux ::=  {: Logger.print("568 else condition "); SemanticAnalysis.getInstance().createElse(); :} ELSE statement:s {: SemanticAnalysis.getInstance().exitCurrentScope(); :} | ;

condition ::= expr:e            {: Logger.print("condition->expression " + e); RESULT = e; :}
    |   declSpecSeq declarator ASSIGNMENT initializeCls
    |   declSpecSeq declarator bracedInitList
    ;

conditionOpt ::= condition | ;

iterationStatement ::= WHILE LPAR condition RPAR statement
    |   DO statement WHILE LPAR expr RPAR SEMICOLON
    |   FOR LPAR forInitStatement conditionOpt SEMICOLON exprOpt RPAR statement
    |   FOR LPAR forRangeDeclaration COLON forRangeInitializer RPAR statement
    ;

forRangeDeclaration ::= typeSpecSeq declarator;

forRangeInitializer ::= expr bracedInitList;

forInitStatement ::=  exprOpt
    | simpleDecl
    ;

jumpStatement ::= BREAK SEMICOLON               {: Logger.print("566 BREAK ;"); :}
    |   CONTINUE SEMICOLON                      {: Logger.print("567 CONTINUE ;"); :}
    |   RETURN SEMICOLON                        {: Logger.print("568 BREAK ;"); :}
    |   RETURN expr:e SEMICOLON                 {: Logger.print("****"); SemanticAnalysis.getInstance().checkReturnedType(e); Logger.print("448 RETURN expr ; " + e); RESULT = e; :}
    |   GOTO IDENTIFIER SEMICOLON
    ;

/**
 * Literals
 */

literal
    ::= integerLiteral:i        {: Logger.print("575 literal (integerLiteral:i) " + i); RESULT = i; :}
    |   characterLiteral:c      {: Logger.print("575 literal (characterLiteral:c)" + c); RESULT = c; :}
    |   floatingLiteral:f       {: Logger.print("575 literal (floatingLiteral:f)" + f); RESULT = f; :}
    |   stringLiteral:s         {: Logger.print("575 literal (stringLiteral:s)" + s); RESULT = s; :}
    |   booleanLiteral:b        {: Logger.print("575 literal (booleanLiteral:b)" + b); RESULT = b; :}
    |   pointerLiteral
    |   userDefinedLiteral
    ;

integerLiteral
    ::= INTEGER:i        {: Logger.print("584 " + i); RESULT = new Expression(new Type("int"), i.toString()); :}
    ;

floatingLiteral
    ::= FLOATING:f       {: Logger.print("585 " + f); RESULT = new Expression(new Type("float"), f.toString()); :}
    |   INTEGER:i        {: Logger.print("585 " + i); RESULT = new Expression(new Type("float"), i.toString()); :}
    ;

booleanLiteral ::= TRUE:t           {: Logger.print("686 " + t); RESULT = new Expression(new Type("bool"), t.toString()); :}
    | FALSE:f                       {: Logger.print("687 " + f); RESULT = new Expression(new Type("bool"), f.toString()); :}
    ;

pointerLiteral ::= NULLPTR;

stringLiteral ::= STRING_LITERAL:s {: Logger.print("628 " + s); RESULT = new Expression(new Type("string"), s.toString()); :} ;

bracedInitListOpt ::= bracedInitList | ;

exprListOpt
    ::= initializeList
    |
    ;

typeIdListOpt ::= typeIdList | ;

typeIdList
    ::= typeId dotsOpt
    |   typeIdList COMMA typeId dotsOpt
    ;

refQualifierOpt
    ::= refQualifier
    |
    ;

refQualifier
    ::= SINGLEAND
    |   DOUBLEAND
    ;

cvQualifierSeq
    ::=  cvQualifier:s                          {: RESULT = s; :}
    |    cvQualifier:a cvQualifierSeq:b         {: RESULT = new Type(((Type)a).getName() + " " + ((Type)b).getName()); :}
    ;

cvQualifier
    ::= CONST              {: Logger.print("724 cvQualifier (CONST)"); RESULT = new Type("const"); :}
    |   VOLATILE           {: Logger.print("724 cvQualifier (VOLATILE)"); RESULT = new Type("volatile"); :}
    |   STATIC             {: Logger.print("724 cvQualifier (STATIC)"); RESULT = new Type("static"); :}
    ;

trailingReturnType
    ::= ARROW trailingTypeSpecSeq abstractDeclaratorOpt
    ;

trailingTypeSpecSeq
    ::= trailingTypeSpec attributeSpecSeqOpt
    |   trailingTypeSpec trailingTypeSpecSeq
    ;

/* noPtrAbstractDeclarator NOT IMPLEMENTED */
ptrAbstractDeclarator ::= noPtrAbstractDeclarator
    |   ptrOperator ptrAbstractDeclaratorOpt
    ;

ptrAbstractDeclaratorOpt ::= ptrAbstractDeclarator | ;

ptrOperator
    ::= STAR attributeSpecSeqOpt:a cvQualifierSeqOpt:c    {: Logger.print("752 ptrOperator (STAR attributeSpecSeqOpt cvQualifierSeqOpt) " + a + " " + c); RESULT = "*"; :}
    |   SINGLEAND attributeSpecSeqOpt
    |   DOUBLEAND attributeSpecSeqOpt
    |   SEPPTR nestedNameSpec SINGLEAND attributeSpecSeqOpt cvQualifierSeqOpt
    |   nestedNameSpec SINGLEAND attributeSpecSeqOpt cvQualifierSeqOpt
    ;

typeSpecSeq ::= typeSpec typeSpecSeq2;

typeSpecSeq2 ::= typeSpecSeq
    |
    ;

typeSpec ::= trailingTypeSpec
    |   classSpec
    |   enumSpec
    ;

/* enumHead NOT IMPLEMENTED
 * enumList enumListOpt NOT IMPLEMENTED
 */
enumSpec ::= enumHead LBRK enumListOpt RBRK
    |   enumHead LBRK enumList COMMA RBRK
    ;

/* simpleTypeSpec NOT IMPLEMENTED
 * elaboratedTypeSpec NOT IMPLEMENTED
 * typenameSpec NOT IMPLEMENTED
 */
/*trailingTypeSpec ::= simpleTypeSpec
 *  |   elaboratedTypeSpec
 *  |   typenameSpec
 *  |   cvQualifier
 *  ;
 */

classSpec ::= classHead LBRK memberSpecificationOpt RBRK;

/* memberSpecification NOT IMPLEMENTED */
memberSpecificationOpt ::= memberSpecification | ;

/* classHeadName NOT IMPLEMENTED */
classHead ::= classKey attributeSpecSeqOpt classHead2;
classHead2 ::= classHeadName classVirtSpecSeqOpt;

classKey ::= CLASS | STRUCT | UNION;

classVirtSpecSeqOpt ::= classVirtSpecSeq | ;

classVirtSpecSeq ::= classVirtSpec
    |   classVirtSpecSeq classVirtSpec
    ;

classVirtSpec ::= FINAL | EXPLICIT;

accessSpecOpt ::= accessSpec | ;

accessSpec ::= PUBLIC
    |   PROTECTED
    |   PRIVATE
    ;

classOrDeclType ::= COLON COLON nestedNameSpec className
    |   nestedNameSpec className
    |   COLON COLON className
    |   className
    |   declTypeSpec
    ;

className ::= IDENTIFIER;


declTypeSpec ::= DECLTYPE LPAR expr RPAR;

attributeSpecSeqOpt
    ::= attributeSpecSeq
    |
    ;

attributeSpecSeq
    ::= attributeSpec
    |   attributeSpecSeq attributeSpec
    ;

attributeSpec ::= LSQRBRK LSQRBRK attributeList RSQRBRK RSQRBRK
    |   alignmentSpec
    ;

attributeList ::= attribute DOTS
    |   attributeList COMMA attribute DOTS
    |   attributeOpt
    |   attributeList COMMA attributeOpt
    ;

attributeOpt
    ::= attribute
    |
    ;

attribute
    ::= attributeToken attributeArgClsOpt
    ;

attributeArgClsOpt
    ::= attributeArgCls
    |
    ;

attributeToken
    ::= IDENTIFIER
    |   attributeScopedToken
    ;

attributeScopedToken ::= IDENTIFIER COLON COLON IDENTIFIER;

attributeArgCls ::= LPAR balancedTokenSeq RPAR;

balancedTokenSeq ::= balancedToken
    |   balancedTokenSeq balancedToken
    ;

/* token NOT IMPLEMENTED */
balancedToken ::= LPAR balancedTokenSeq RPAR
    |   LSQRBRK balancedTokenSeq RSQRBRK
    |   LBRK balancedTokenSeq RBRK
    |   token
    ;

/* ISSUE #2 - rule "alignment-expression" not defined in the grammar ref */
alignmentSpec ::= ALIGNAS LPAR typeId dotsOpt RPAR;

/**
 * Empty Declaration
 */
emptyDeclaration ::= SEMICOLON;

dotsOpt ::= DOTS | ;

overloadableOperator ::= NEW;